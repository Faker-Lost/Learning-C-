# MiniSTL

## 1.Vector 容器 2024.5.27

**1 vector的扩容过程**

1.分配一个更大的内存块，通常时当前大小的两倍；

2.将当前的所有元素移到新的内存中；

3.销毁旧元素，并释放旧内存块；

4.插入新元素

**2 vector中push_back和emplace的区别：**

`std::vector::push_back` 和 `std::vector::emplace_back` 都是在 `std::vector` 的末尾添加一个新元素，但它们添加元素的方式不同。

- `push_back` 会对给定的对象进行拷贝或移动构造，以将元素添加到 `vector` 的末尾。
- `emplace_back` 则使用给定的参数直接在 `vector` 的末尾构造一个元素，无需拷贝或移动操作，这通常更高效。

**3 reserve()的使用：**

`std::vector::reserve()` 用于预分配内存，以避免在添加新元素时重新分配内存。当知道将要存储大量元素，但又不想在每次插入时都可能发生内存重新分配时，使用 `reserve()` 可以提高性能。这样可以减少因扩容导致的不必要的内存分配和元素拷贝。

**4 如何减少vector的占用空间：**

可以使用 `std::vector::shrink_to_fit` 方法来请求移除未使用的容量，减少 `vector` 的内存使用。这个函数是 C++11 引入的，它会尝试压缩 `std::vector` 的容量，使其等于其大小。但是，这只是一个请求，并不保证容量会减少，因为这依赖于实现。

**5 如何检查vector为空：**

使用 `std::vector::empty()` 方法可以检查 `vector` 是否没有元素。这比使用 `size()` 方法（比较 `size() == 0`）更首选，因为 `empty()` 通常可以保证是常数时间复杂度的操作。

**6 迭代器失效，如何避免:**

当 `vector` 进行操作，如增加或删除元素，尤其是在中间插入或删除元素时，迭代器可能会失效。例如：

- 如果 `vector` 进行了重新分配，所有指向元素的迭代器都会失效。
- 如果在 `vector` 中间插入或删除元素，从该点到末尾的所有迭代器都会失效。

解决方案是最好使用标准库提供的算法，如 `std::remove` 和 `std::remove_if` 结合 `vector::erase` 方法来删除元素。这些算法在设计时已经考虑了迭代器失效的问题。